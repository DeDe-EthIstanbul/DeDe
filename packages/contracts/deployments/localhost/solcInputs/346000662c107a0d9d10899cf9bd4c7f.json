{
  "language": "Solidity",
  "sources": {
    "contracts/DeDe.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract DeDe {\n    uint public settlementDuration;\n    uint public stakeAmount;\n    uint public currentId;\n    mapping(uint => Shipment) public shipments;\n    mapping(uint => bool) public pickedUpShipments;\n    mapping(uint => bool) public fulfilledShipments;\n    mapping(address => uint) public withdrawableBalance;\n    address payable public owner;\n\n    struct Shipment {\n        uint id;\n        uint shipmentCost; // Earnings for courier when shipment is done\n        uint settlementDeadline; // When should the receiver accept/dispute the shipment as complete\n        uint stake; // Amount courier staked to make this shipment\n        address courier;\n        address sender;\n        address receiver;\n        address paidBy;\n        bool valid;\n    }\n\n    event ShipmentRequested(uint shipmentId, address sender, address receiver);\n    event ShipmentPickedUp(uint shipmentId, address courier);\n    event ShipmentCompleted(uint shipmentId, address courier);\n\n    constructor(uint _settlementDuration, uint _stakeAmount) payable {\n        currentId = 0;\n        stakeAmount = _stakeAmount;\n        settlementDuration = _settlementDuration;\n        owner = payable(msg.sender);\n    }\n\n    /**\n     * @dev Request a shipment\n     */\n    function requestShipment(uint _shipmentCost, address _sender, address _receiver) public payable {\n        require(msg.value >= _shipmentCost, \"Shipment cost insufficient\");\n        uint id = currentId;\n        currentId++;\n        uint shipmentId = id;\n\n        Shipment memory shipment = Shipment(\n            shipmentId,\n            _shipmentCost,\n            block.number + settlementDuration,\n            stakeAmount,\n            address(0),\n            _sender,\n            _receiver,\n            msg.sender,\n            true\n        );\n        shipments[shipmentId] = shipment;\n        emit ShipmentRequested(shipmentId, _sender, _receiver);\n    }\n\n    /**\n     * @dev Pickup a shipment\n     */\n    function pickUpShipment(uint _shipmentId) public payable {\n        require(pickedUpShipments[_shipmentId] == false, \"Shipment has already been picked up\");\n        require(fulfilledShipments[_shipmentId] == false, \"Shipment has already been fulfilled\");\n        require(msg.value >= stakeAmount, \"Stake amount insufficient\");\n\n        Shipment memory shipment = shipments[_shipmentId];\n        require(shipment.valid == true, \"Shipment is not valid\");\n        require(shipment.settlementDeadline > block.number, \"Shipment has expired\");\n\n        pickedUpShipments[_shipmentId] = true;\n        shipment.courier = msg.sender;\n        shipment.stake = msg.value;\n        shipments[_shipmentId] = shipment;\n        emit ShipmentPickedUp(_shipmentId, msg.sender);\n    }\n\n    /** TODO: Add attestations */\n    function completeShipment(uint _shipmentId) public payable {\n        require(pickedUpShipments[_shipmentId] == true, \"Shipment has not been picked up\");\n        require(fulfilledShipments[_shipmentId] == false, \"Shipment has already been fulfilled\");\n\n        Shipment memory shipment = shipments[_shipmentId];\n        require(shipment.valid == true, \"Shipment is not valid\");\n        require(shipment.settlementDeadline > block.number, \"Shipment has expired\");\n        require(shipment.courier == msg.sender, \"Sender is not the courier\");\n\n        fulfilledShipments[_shipmentId] = true;\n        address payable courier = payable(shipment.courier);\n\n        // Return stake to courier\n        courier.transfer(shipment.stake);\n        shipments[_shipmentId] = shipment;\n        emit ShipmentCompleted(_shipmentId, msg.sender);\n    }\n\n    /**\n     * Receiver or courier is unhappy, can file a dispute\n     */\n    function dispute(uint _shipmentId, address disputer) public {\n        // TODO\n        // Would need to call to an insurance contract and settle things that way\n    }\n\n    /**\n     * Called by the receiver. Only if the receiver is happy with the shipment, the courier gets paid.\n     */\n    function disburse(uint _shipmentId) public {\n        require(pickedUpShipments[_shipmentId] == true, \"Shipment is not picked up\");\n        require(fulfilledShipments[_shipmentId] == true, \"Shipment is not fulfilled\");\n\n        Shipment memory shipment = shipments[_shipmentId];\n        require(shipment.valid == true, \"Shipment is not valid\");\n        require(shipment.receiver == msg.sender, \"Caller is not the receiver\");\n\n        // Set it to not valid anymore since its done\n        shipment.valid = false;\n        shipments[_shipmentId] = shipment;\n        withdrawableBalance[shipment.courier] += shipment.shipmentCost;\n    }\n\n    /**\n     * If nobody did anything after the deadline, then the settlement can be made\n     * Anyone can call this. In the future, you can incentivize by giving a cut to the caller\n     */\n    function settle(uint _shipmentId) public {\n        Shipment memory shipment = shipments[_shipmentId];\n        require(shipment.valid == true, \"Shipment is not valid\");\n        require(shipment.settlementDeadline <= block.number, \"Shipment has not expired\");\n\n        shipment.valid = false;\n        shipments[_shipmentId] = shipment;\n\n        // If fulfilled but receiver didn't disburse, the withdrawable balance opens for the courier\n        if (fulfilledShipments[_shipmentId]) {\n            withdrawableBalance[shipment.courier] += shipment.shipmentCost;\n        }\n\n        // If picked up but not fulfilled, the withdrawable balance opens for the sender\n        if (pickedUpShipments[_shipmentId] && !fulfilledShipments[_shipmentId]) {\n            withdrawableBalance[shipment.sender] += shipment.shipmentCost;\n        }\n    }\n\n    /**\n     * Withdraw balance\n     */\n    function withdraw() public {\n        require(withdrawableBalance[msg.sender] > 0, \"No withdrawable balance\");\n        uint amount = withdrawableBalance[msg.sender];\n        withdrawableBalance[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}